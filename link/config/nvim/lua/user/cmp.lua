local cmp = require('cmp')
local cmp_kinds = {
	Text          = 'Ôî´ ',
	Method        = 'Ôûî ',
	Function      = 'Ôûî ',
	Constructor   = 'Ôê• ',
	Field         = 'Ôßº',
	Variable      = 'ùëã ',
	Class         = 'ÔÉ® ',
	Interface     = 'ÔÖê ',
	Module        = 'Ô£ñ ',
	Property      = 'Óò§ ',
	Unit          = 'Ôëµ ',
	Value         = 'Ô¢ü ',
	Enum          = 'Ôêµ ',
	Keyword       = 'Ô†Ö ',
	Snippet       = 'Ô¨å ',
	Color         = 'Óà´ ',
	File          = 'ÔÖõ ',
	Reference     = 'Ôöê ',
	Folder        = 'ÔÑï ',
	EnumMember    = 'ÔÖù ',
	Constant      = 'Óà¨ ',
	Struct        = 'ÔÉä ',
	Event         = 'ÔÉß ',
	Operator      = 'Ô¨¶' ,
	TypeParameter = 'Óòé ',
}

local has_words_before = function()
  local cursor = vim.api.nvim_win_get_cursor(0)
  return (vim.api.nvim_buf_get_lines(0, cursor[1] - 1, cursor[1], true)[1] or ''):sub(cursor[2], cursor[2]):match('%s')
end

local feedkey = function(key, mode)
  vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(key, true, true, true), mode, true)
end

cmp.setup {
	completion = {
		completeopt = 'menu,menuone,noinsert',
	},

	formatting = {
		format = function(_, vim_item)
			vim_item.kind = (cmp_kinds[vim_item.kind] or '') .. vim_item.kind
			return vim_item
		end,
	},

	snippet = {
		expand = function(args)
			vim.fn['vsnip#anonymous'](args.body)
		end,
	},

	mapping = {
		['<up>'] = cmp.mapping.select_prev_item(),
		['<down>'] = cmp.mapping.select_next_item(),
		['<C-k>'] = cmp.mapping.select_prev_item(),
		['<C-j>'] = cmp.mapping.select_next_item(),
		['<C-d>'] = cmp.mapping.scroll_docs(-4),
		['<C-f>'] = cmp.mapping.scroll_docs(4),
		['<C-Space>'] = cmp.mapping.complete(),
		['<C-e>'] = cmp.mapping.close(),
		['<CR>'] = cmp.mapping.confirm {
			behavior = cmp.ConfirmBehavior.Replace,
			select = true,
		},

		["<Tab>"] = cmp.mapping(function(fallback)
			local copilot_keys = vim.fn["copilot#Accept"]("")
			if cmp.visible() then
				cmp.select_next_item()
			elseif copilot_keys ~= "" then
				vim.api.nvim_feedkeys(copilot_keys, "i", false)
			elseif vim.fn["vsnip#available"]() == 1 then
				feedkey("<Plug>(vsnip-expand-or-jump)", "")
			elseif has_words_before() then
				cmp.complete()
			else
				fallback() -- The fallback function sends a already mapped key. In this case, it's probably `<Tab>`.
			end
		end, { "i", "s" }),

		["<S-Tab>"] = cmp.mapping(function()
			if cmp.visible() then
				cmp.select_prev_item()
			elseif vim.fn["vsnip#jumpable"](-1) == 1 then
				feedkey("<Plug>(vsnip-jump-prev)", "")
			end
		end, { "i", "s" }),
	},

	sources = {
		{ name = 'path'     },
		{ name = 'vsnip'    },
		{ name = 'orgmode' },
		{ name = 'nvim_lsp' },
		{ name = 'nvim_lsp_signature_help' },
		{ name = 'git'      },
		{ name = 'buffer',
			option = {
				get_bufnrs = function()
					local bufs = {}
					for _, win in ipairs(vim.api.nvim_list_wins()) do
						bufs[vim.api.nvim_win_get_buf(win)] = true
					end
					return vim.tbl_keys(bufs)
				end
			}
		},
	},
}
